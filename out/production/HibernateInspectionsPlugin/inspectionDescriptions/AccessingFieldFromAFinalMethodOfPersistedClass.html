<html>
<body>
This inspection reports when a final method of a persisted class
(persisted with Hibernate or similar, annotated with @Entity, @MappedSuperclass, or @Embeddable)
uses direct field access.
<p>
    If a class is persisted (with Hibernate or similar), and proxies are on, a final method that directly accesses a field is ALWAYS a bug.

<p>
    A final method does not prevent Hibernate from creating a proxy. Final methods that don't access state are fine.
    Final methods that only access state through another method are also fine.
    But the final method will fail (and may SILENTLY fail) if it uses a direct instance field,
    since field values will not be initialized (will be null, zero or false).
    There are 3 ways to solve this:
<ul>
    <li>First is not to declare the method final.</li>
    <li>Second is not to directly access fields from final methods.</li>
    <li>Third is to disable proxy generation by setting lazy="false" (not recommended, for performance reasons).</li>
</ul>

<p>
    <b>Note 1:</b> This inspection only covers JPA/Hibernate <b>annotated</b> classes. It does <b>not</b> check XML file mappings.

<p>
    <b>Note 2:</b> If you use <b>property access type strategy</b>, you may access the identifier without forcing a proxy initialization.
    This isn’t true if you map the identifier property with <b>direct field access type strategy</b>;
    Hibernate then doesn’t even know that the getId() method exists. If you call it, the proxy has to be initialized.
    However, there is a way to avoid initializing the proxy even when using direct field access strategy.
    Just mark the getId() method as final, so that proxies cannot override it. Then, calling the method cannot run any proxy code,
    and thus cannot initialize the proxy. The method itself checks if its instance is a proxy, and in this case returns the id from the proxy.
    If the instance is the real object, it returns the id.
    This is a valid use (maybe the only one?) of a final method that directly accesses state in a proxyable persisted class.
    You should then suppress the warning generated by this inspection:

<blockquote>
    <pre>@SuppressWarnings ("AccessingFieldFromAFinalMethodOfPersistedClass")
public final long getId() {
    if (this instanceof HibernateProxy) {
    return (long)((HibernateProxy)this).getHibernateLazyInitializer().getIdentifier();
    }
    else { return id; }
}</pre>
</blockquote>

<p>
    <b>More information:</b>
<ul>
    <li><a href="https://youtrack.jetbrains.com/issue/IDEA-128132">Relevant IntelliJ IDEA bug report</a></li>
    <li><a href="http://stackoverflow.com/questions/6608222/does-a-final-method-prevent-hibernate-from-creating-a-proxy-for-such-an-entity">
        Stackoverflow question</a></li>
</ul>

</body>
</html>
